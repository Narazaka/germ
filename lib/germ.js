// Generated by CoffeeScript 1.7.1

/* (C) 2014 Narazaka : Licensed under The MIT License - http://narazaka.net/license/MIT?2014 */

/* This software is using Apache License software "request" */
var Germ, JSZip, fs, jconv, jsyaml, mkpath, path, request, url,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

fs = require('fs');

path = require('path');

url = require('url');

request = require('request');

jsyaml = require('js-yaml');

JSZip = require('jszip');

jconv = require('jconv');

mkpath = require('mkpath');

Germ = {};

Germ.Get = (function() {
  function Get() {}

  Get.prototype.verbose = false;

  Get.prototype.install = function(package_name, callback) {
    return this.get_package_database((function(_this) {
      return function(package_database) {
        var archive_path;
        archive_path = _this.get_archive_path(package_name, package_database);
        return _this.get_package_information(package_name, archive_path, function(package_information) {
          return _this.get_archive(archive_path, function(data, response) {
            var error;
            try {
              return _this.place_archive(data, package_name, package_information, function(install_information) {
                console.warn('install finished');
                if (callback != null) {
                  return callback(install_information);
                }
              });
            } catch (_error) {
              error = _error;
              throw error;
            }
          });
        });
      };
    })(this));
  };

  Get.prototype.remove = function(package_name, callback) {
    return this.remove_installed(package_name, function(install_information) {
      console.warn('remove finished');
      if (callback != null) {
        return callback(install_information);
      }
    });
  };

  Get.prototype.search = function(package_name_part, callback) {
    return this.get_package_database(function(package_database) {
      var package_matched, package_name;
      package_matched = [];
      for (package_name in package_database) {
        if (-1 !== package_name.indexOf(package_name_part)) {
          package_matched.push(package_name);
        }
      }
      return callback(package_matched);
    });
  };

  Get.prototype.list = function(callback) {
    return this.get_package_database((function(_this) {
      return function(package_database) {
        return callback(package_database);
      };
    })(this));
  };

  Get.prototype.information = function(package_name, callback) {
    return this.get_package_database((function(_this) {
      return function(package_database) {
        var archive_path;
        archive_path = _this.get_archive_path(package_name, package_database);
        return _this.get_package_information(package_name, archive_path, function(package_information) {
          return callback(package_information);
        });
      };
    })(this));
  };

  Get.prototype.get = function(package_name, callback) {
    return this.get_package_database((function(_this) {
      return function(package_database) {
        var archive_path;
        archive_path = _this.get_archive_path(package_name, package_database);
        return _this.get_package_information(package_name, archive_path, function(package_information) {
          return _this.get_archive(archive_path, function(data, response) {
            var archive_filepath;
            archive_filepath = path.basename(response.request.uri.path);
            fs.writeFileSync(archive_filepath, data, 'binary');
            if (_this.verbose) {
              console.warn('-> ', archive_filepath);
            }
            console.warn('get finished');
            if (callback != null) {
              return callback(archive_filepath);
            }
          });
        });
      };
    })(this));
  };

  Get.prototype.get_package_list = function(callback) {
    throw 'prease imprement';
  };

  Get.prototype.get_package_txt = function(package_name, archive_path, callback) {
    throw 'prease imprement';
  };

  Get.prototype.get_archive = function(archive_path, callback) {
    throw 'prease imprement';
  };

  Get.prototype.get_archive_path = function(package_name, package_database) {
    var archive_path;
    archive_path = package_database[package_name];
    if (archive_path != null) {
      if (this.verbose) {
        console.warn('archive path is ' + archive_path);
      }
      return archive_path;
    } else {
      throw "package [" + package_name + "] not found";
    }
  };

  Get.prototype.get_package_database = function(callback) {
    if (this.verbose) {
      console.warn('Getting package database');
    }
    return this.get_package_list((function(_this) {
      return function(data) {
        var archive_path, line, lines, package_database, package_name, _i, _len, _ref;
        package_database = {};
        lines = data.split(/\r?\n/);
        lines.pop();
        for (_i = 0, _len = lines.length; _i < _len; _i++) {
          line = lines[_i];
          _ref = line.split(/\t/), package_name = _ref[0], archive_path = _ref[1];
          package_database[package_name] = archive_path;
        }
        if (_this.verbose) {
          console.warn('Got package database.');
        }
        return callback(package_database);
      };
    })(this));
  };

  Get.prototype.get_package_information = function(package_name, archive_path, callback) {
    if (this.verbose) {
      console.warn('Getting package information');
    }
    return this.get_package_txt(package_name, archive_path, (function(_this) {
      return function(data) {
        var package_information;
        package_information = jsyaml.safeLoad(data);
        if (_this.verbose) {
          console.warn('Got package information');
        }
        return callback(package_information);
      };
    })(this));
  };

  Get.prototype.get_archive_place_root_directory = function(package_information) {
    var cwd, place_on, root_directory;
    cwd = process.cwd();
    place_on = package_information.place_on;
    if (place_on != null) {
      if (place_on === 'ghost') {
        root_directory = this.detect_ghost_root_directory(cwd);
        if (root_directory != null) {
          return path.normalize(root_directory);
        }
      } else if (place_on === 'baseware') {
        root_directory = this.detect_baseware_root_directory(cwd);
        if (root_directory != null) {
          return path.normalize(root_directory);
        }
      }
    }
    return path.normalize(cwd);
  };

  Get.prototype.get_archive_place_root_directories = function() {
    var baseware_root_directory, cwd, directories, ghost_root_directory;
    cwd = path.normalize(process.cwd());
    ghost_root_directory = path.normalize(this.detect_ghost_root_directory(cwd));
    baseware_root_directory = path.normalize(this.detect_baseware_root_directory(cwd));
    directories = {};
    directories[ghost_root_directory] = 1;
    directories[baseware_root_directory] = 2;
    directories[cwd] = 3;
    return Object.keys(directories).sort(function(a, b) {
      return directories[a] - directories[b];
    });
  };

  Get.prototype.get_archive_place_directory = function(package_information, archive_place_root_directory) {
    var place;
    place = package_information.place;
    if (place == null) {
      place = '';
    }
    return path.join(archive_place_root_directory, '.' + place);
  };

  Get.prototype.encode_package_name = function(package_name) {
    return encodeURIComponent(package_name).replace(/\*/g, '%2a');
  };

  Get.prototype.install_information_filename = function(package_name) {
    return '.germ.package.' + this.encode_package_name(package_name);
  };

  Get.prototype.install_information_filepath = function(package_name, archive_place_root_directory) {
    return path.join(archive_place_root_directory, this.install_information_filename(package_name));
  };

  Get.prototype.place_archive = function(data, package_name, package_information, callback) {
    var archive_place_directory, archive_place_root_directory, content, dirpath, error, filename, filename_key, filepath, install_information, zip, _ref;
    archive_place_root_directory = this.get_archive_place_root_directory(package_information);
    archive_place_directory = this.get_archive_place_directory(package_information, archive_place_root_directory);
    zip = new JSZip();
    zip.load(data);
    install_information = {
      package_information: package_information,
      elements: []
    };
    _ref = zip.files;
    for (filename_key in _ref) {
      content = _ref[filename_key];
      filename = path.normalize(jconv.decode(new Buffer(content.name, 'ascii'), 'SJIS'));
      filepath = path.join(archive_place_directory, filename);
      dirpath = path.dirname(filepath);
      install_information.elements.push(filename);
      if (this.verbose) {
        console.warn('-> ', filepath);
      }
      if (content.options.dir) {
        if (!fs.existsSync(dirpath)) {
          mkpath.sync(dirpath);
        }
      } else {
        if (!fs.existsSync(dirpath)) {
          mkpath.sync(dirpath);
        }
        try {
          fs.writeFileSync(filepath, content.asBinary(), 'binary');
        } catch (_error) {
          error = _error;
          throw error;
        }
      }
    }
    fs.writeFileSync(this.install_information_filepath(package_name, archive_place_root_directory), jsyaml.safeDump(install_information), 'utf8');
    if (callback != null) {
      return callback(install_information);
    }
  };

  Get.prototype.remove_installed = function(package_name, callback) {
    var archive_place_directory, archive_place_root_directories, archive_place_root_directory, directories, directorypath, element, elementpath, elements, error, install_information, install_information_filepath, install_information_str, package_information, stats, _i, _j, _k, _len, _len1, _len2, _ref;
    archive_place_root_directories = this.get_archive_place_root_directories();
    install_information_str = null;
    for (_i = 0, _len = archive_place_root_directories.length; _i < _len; _i++) {
      archive_place_root_directory = archive_place_root_directories[_i];
      try {
        install_information_filepath = this.install_information_filepath(package_name, archive_place_root_directory);
        install_information_str = fs.readFileSync(install_information_filepath, 'utf8');
        break;
      } catch (_error) {
        error = _error;
        install_information_str = null;
      }
    }
    if (install_information_str == null) {
      throw 'cannot find install information file.';
    }
    try {
      install_information = jsyaml.safeLoad(install_information_str);
    } catch (_error) {
      error = _error;
      throw 'broken install information file. : ' + install_information_filepath;
    }
    package_information = install_information.package_information;
    elements = install_information.elements;
    archive_place_directory = this.get_archive_place_directory(package_information, archive_place_root_directory);
    try {
      directories = [];
      for (_j = 0, _len1 = elements.length; _j < _len1; _j++) {
        element = elements[_j];
        elementpath = path.join(archive_place_directory, element);
        stats = fs.statSync(elementpath);
        if (stats.isDirectory()) {
          directories.push(elementpath);
        } else {
          if (this.verbose) {
            console.warn('-x ', elementpath);
          }
          fs.unlinkSync(elementpath);
        }
      }
      _ref = directories.sort().reverse();
      for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
        directorypath = _ref[_k];
        try {
          fs.rmdirSync(directorypath);
          if (this.verbose) {
            console.warn('-x ', directorypath);
          }
        } catch (_error) {
          error = _error;
          if (this.verbose) {
            console.warn('-= ', directorypath);
          }
        }
      }
      fs.unlinkSync(install_information_filepath);
    } catch (_error) {
      error = _error;
      throw error;
    }
    if (callback != null) {
      return callback(install_information);
    }
  };

  Get.prototype.detect_ghost_root_directory = function(directory) {
    var path_separator, test_directory, test_directory_old;
    if (directory.match(/\//)) {
      path_separator = '/';
    } else {
      path_separator = '\\';
    }
    test_directory = directory;
    test_directory_old = null;
    while (test_directory_old !== test_directory && !fs.existsSync(path.join(test_directory, 'install.txt'))) {
      test_directory_old = test_directory;
      test_directory = path.dirname(test_directory);
    }
    if (test_directory_old === test_directory) {
      return null;
    } else {
      return test_directory;
    }
  };

  Get.prototype.detect_baseware_root_directory = function(directory) {
    var path_separator, test_directory, test_directory_old;
    if (directory.match(/\//)) {
      path_separator = '/';
    } else {
      path_separator = '\\';
    }
    test_directory = directory;
    test_directory_old = null;
    while ((test_directory_old !== test_directory) && !((!fs.existsSync(path.join(test_directory, 'install.txt'))) && (fs.existsSync(path.join(test_directory, 'balloon'))) && (!fs.existsSync(path.join(test_directory, 'shell'))))) {
      test_directory_old = test_directory;
      test_directory = path.dirname(test_directory);
    }
    if (test_directory_old === test_directory) {
      return null;
    } else {
      return test_directory;
    }
  };

  return Get;

})();

Germ.Get.Sync = (function(_super) {
  __extends(Sync, _super);

  function Sync() {}

  Sync.prototype.user_agent = 'germ';

  Sync.prototype.package_list_repository_url = function() {
    var package_list_repository_url;
    package_list_repository_url = url.parse('http://germ.narazaka.net/package_list_repository');
    if (this.verbose) {
      console.warn('package_list_repository_url = ' + url.format(package_list_repository_url));
    }
    return package_list_repository_url;
  };

  Sync.prototype.package_txt_url = function(archive_path) {
    var package_txt_url;
    package_txt_url = url.parse(url.resolve(archive_path, './package.txt'));
    if (this.verbose) {
      console.warn('package_txt_url = ' + url.format(package_txt_url));
    }
    return package_txt_url;
  };

  Sync.prototype.package_txt_repository_url = function(package_name) {
    var package_txt_repository_url;
    package_txt_repository_url = url.parse('http://germ.narazaka.net/package_txt_repository/' + package_name + '/package.txt');
    if (this.verbose) {
      console.warn('package_txt_repository_url = ' + url.format(package_txt_repository_url));
    }
    return package_txt_repository_url;
  };

  Sync.prototype.get_package_list = function(callback) {
    return this.get_file(this.package_list_repository_url(), function(error, response, body) {
      if (error) {
        throw error;
      } else if (response.statusCode === 404) {
        throw 'package_list not found';
      } else if (response.statusCode === 200) {
        return callback(body);
      } else {
        throw response.statusCode;
      }
    });
  };

  Sync.prototype.get_package_txt = function(package_name, archive_path, callback) {
    return this.get_file(this.package_txt_url(archive_path), (function(_this) {
      return function(error, response, body) {
        if (error) {
          throw error;
        } else if (response.statusCode === 404) {
          console.warn('package.txt not found in site : using package.txt repository');
          return _this.get_file(_this.package_txt_repository_url(package_name), function(error, response, body) {
            if (error) {
              throw error;
            } else if (response.statusCode === 404) {
              throw 'package.txt not found anywhere';
            } else if (response.statusCode === 200) {
              return callback(body);
            } else {
              throw response.statusCode;
            }
          });
        } else if (response.statusCode = 200) {
          return callback(body);
        } else {
          throw response.statusCode;
        }
      };
    })(this));
  };

  Sync.prototype.get_archive = function(archive_path, callback) {
    var archive_url;
    if (this.verbose) {
      console.warn('Getting archive');
    }
    archive_url = url.parse(archive_path);
    return this.get_binary_file(archive_url, (function(_this) {
      return function(error, response, body) {
        if (error) {
          throw error;
        } else if (response.statusCode === 404) {
          throw 'archive not found in site';
        } else if (response.statusCode = 200) {
          if (_this.verbose) {
            console.warn('Got archive');
          }
          return callback(body, response);
        } else {
          throw response.statusCode;
        }
      };
    })(this));
  };

  Sync.prototype.get_file = function(file_url, callback) {
    return request.get({
      uri: file_url,
      headers: {
        'User-Agent': this.user_agent
      }
    }, callback);
  };

  Sync.prototype.get_binary_file = function(file_url, callback) {
    return request.get({
      uri: file_url,
      encoding: 'binary',
      headers: {
        'User-Agent': this.user_agent
      }
    }, callback);
  };

  return Sync;

})(Germ.Get);

module.exports = Germ;

//# sourceMappingURL=germ.map
