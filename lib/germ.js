// Generated by CoffeeScript 1.7.1

/* (C) 2014 Narazaka : Licensed under The MIT License - http://narazaka.net/license/MIT?2014 */

/* This software is using Apache License software "request" */
var Germ, JSZip, fs, jconv, jsyaml, mkpath, path, request, url,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

fs = require('fs');

path = require('path');

url = require('url');

request = require('request');

jsyaml = require('js-yaml');

JSZip = require('jszip');

jconv = require('jconv');

mkpath = require('mkpath');

Germ = {};

Germ.Get = (function() {
  function Get() {}

  Get.prototype.verbose = false;

  Get.prototype.install = function(package_name, callback) {
    return this.get_package_database((function(_this) {
      return function(package_database) {
        var archive_path;
        archive_path = _this.get_archive_path(package_name, package_database);
        return _this.get_package_information(package_name, archive_path, function(package_information) {
          return _this.get_archive(archive_path, function(data, response) {
            var archive_place_root_directory, error;
            archive_place_root_directory = _this.get_archive_place_root_directory(package_information);
            try {
              return _this.place_archive(data, package_name, archive_place_root_directory, function(install_information) {
                console.warn('install finished');
                if (callback != null) {
                  return callback(install_information);
                }
              });
            } catch (_error) {
              error = _error;
              throw error;
            }
          });
        });
      };
    })(this));
  };

  Get.prototype.remove = function(package_name, callback) {
    var directories, directory, element, error, install_information, install_information_filename, stats, _i, _j, _len, _len1, _ref, _ref1;
    try {
      install_information_filename = this.install_information_filename(package_name);
      install_information = jsyaml.safeLoad(fs.readFileSync(install_information_filename, 'utf8'));
    } catch (_error) {
      error = _error;
      throw error;
    }
    try {
      directories = [];
      _ref = install_information.elements;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        element = _ref[_i];
        stats = fs.statSync(element);
        if (stats.isDirectory()) {
          directories.push(element);
        } else {
          if (this.verbose) {
            console.warn('-x ', element);
          }
          fs.unlinkSync(element);
        }
      }
      _ref1 = directories.sort().reverse();
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        directory = _ref1[_j];
        try {
          fs.rmdirSync(directory);
          if (this.verbose) {
            console.warn('-x ', directory);
          }
        } catch (_error) {
          error = _error;
          if (this.verbose) {
            console.warn('-= ', directory);
          }
        }
      }
      fs.unlinkSync(install_information_filename);
    } catch (_error) {
      error = _error;
      throw error;
    }
    console.warn('remove finished');
    if (callback != null) {
      return callback(install_information);
    }
  };

  Get.prototype.search = function(package_name_part, callback) {
    return this.get_package_database(function(package_database) {
      var package_matched, package_name;
      package_matched = [];
      for (package_name in package_database) {
        if (-1 !== package_name.indexOf(package_name_part)) {
          package_matched.push(package_name);
        }
      }
      return callback(package_matched);
    });
  };

  Get.prototype.list = function(callback) {
    return this.get_package_database((function(_this) {
      return function(package_database) {
        return callback(package_database);
      };
    })(this));
  };

  Get.prototype.information = function(package_name, callback) {
    return this.get_package_database((function(_this) {
      return function(package_database) {
        var archive_path;
        archive_path = _this.get_archive_path(package_name, package_database);
        return _this.get_package_information(package_name, archive_path, function(package_information) {
          return callback(package_information);
        });
      };
    })(this));
  };

  Get.prototype.get = function(package_name, callback) {
    return this.get_package_database((function(_this) {
      return function(package_database) {
        var archive_path;
        archive_path = _this.get_archive_path(package_name, package_database);
        return _this.get_package_information(package_name, archive_path, function(package_information) {
          return _this.get_archive(archive_path, function(data, response) {
            var archive_filepath;
            archive_filepath = path.basename(response.request.uri.path);
            fs.writeFileSync(archive_filepath, data, 'binary');
            if (_this.verbose) {
              console.warn('-> ', archive_filepath);
            }
            console.warn('get finished');
            if (callback != null) {
              return callback(archive_filepath);
            }
          });
        });
      };
    })(this));
  };

  Get.prototype.get_package_list = function(callback) {
    throw 'prease imprement';
  };

  Get.prototype.get_package_txt = function(package_name, archive_path, callback) {
    throw 'prease imprement';
  };

  Get.prototype.get_archive = function(archive_path, callback) {
    throw 'prease imprement';
  };

  Get.prototype.get_archive_path = function(package_name, package_database) {
    var archive_path;
    archive_path = package_database[package_name];
    if (archive_path != null) {
      if (this.verbose) {
        console.warn('archive path is ' + archive_path);
      }
      return archive_path;
    } else {
      throw "package [" + package_name + "] not found";
    }
  };

  Get.prototype.get_package_database = function(callback) {
    if (this.verbose) {
      console.warn('Getting package database');
    }
    return this.get_package_list((function(_this) {
      return function(data) {
        var archive_path, line, lines, package_database, package_name, _i, _len, _ref;
        package_database = {};
        lines = data.split(/\r?\n/);
        lines.pop();
        for (_i = 0, _len = lines.length; _i < _len; _i++) {
          line = lines[_i];
          _ref = line.split(/\t/), package_name = _ref[0], archive_path = _ref[1];
          package_database[package_name] = archive_path;
        }
        if (_this.verbose) {
          console.warn('Got package database.');
        }
        return callback(package_database);
      };
    })(this));
  };

  Get.prototype.get_package_information = function(package_name, archive_path, callback) {
    if (this.verbose) {
      console.warn('Getting package information');
    }
    return this.get_package_txt(package_name, archive_path, (function(_this) {
      return function(data) {
        var package_information;
        package_information = jsyaml.safeLoad(data);
        if (_this.verbose) {
          console.warn('Got package information');
        }
        return callback(package_information);
      };
    })(this));
  };

  Get.prototype.get_archive_place_root_directory = function(package_information) {
    var cwd, ghost_root_directory, place;
    cwd = process.cwd();
    place = package_information.place;
    if (place != null) {
      ghost_root_directory = this.detect_ghost_root_directory(cwd);
      if (ghost_root_directory != null) {
        return path.join(ghost_root_directory, '.' + place);
      }
    }
    return cwd;
  };

  Get.prototype.encode_package_name = function(package_name) {
    return encodeURIComponent(package_name).replace(/\*/g, '%2a');
  };

  Get.prototype.install_information_filename = function(package_name) {
    return '.germ.package.' + this.encode_package_name(package_name);
  };

  Get.prototype.place_archive = function(data, package_name, root_directory, callback) {
    var content, dirpath, error, filename, filename_key, filepath, filepath_local, install_information, zip, _ref;
    zip = new JSZip();
    zip.load(data);
    install_information = {
      package_name: package_name,
      elements: []
    };
    _ref = zip.files;
    for (filename_key in _ref) {
      content = _ref[filename_key];
      filename = jconv.decode(new Buffer(content.name, 'ascii'), 'SJIS');
      filepath_local = path.join(filename);
      filepath = path.join(root_directory, filepath_local);
      dirpath = path.dirname(filepath);
      install_information.elements.push(filepath_local);
      if (this.verbose) {
        console.warn('-> ', filepath);
      }
      if (content.options.dir) {
        if (!fs.existsSync(dirpath)) {
          mkpath.sync(dirpath);
        }
      } else {
        if (!fs.existsSync(dirpath)) {
          mkpath.sync(dirpath);
        }
        try {
          fs.writeFileSync(filepath, content.asBinary(), 'binary');
        } catch (_error) {
          error = _error;
          throw error;
        }
      }
    }
    fs.writeFileSync(path.join(root_directory, this.install_information_filename(package_name)), jsyaml.safeDump(install_information), 'utf8');
    if (callback != null) {
      return callback(install_information);
    }
  };

  Get.prototype.detect_ghost_root_directory = function(directory) {
    var path_separator, test_directory, test_directory_old;
    if (directory.match(/\//)) {
      path_separator = '/';
    } else {
      path_separator = '\\';
    }
    test_directory = directory;
    test_directory_old = null;
    while (test_directory_old !== test_directory && !fs.existsSync(path.join(test_directory, 'install.txt'))) {
      test_directory_old = test_directory;
      test_directory = path.dirname(test_directory);
    }
    if (test_directory_old === test_directory) {
      return null;
    } else {
      return test_directory;
    }
  };

  return Get;

})();


/*
		if directory.match /\//
			path_separator = '/'
		else
			path_separator = '\\'
		hierarchy = directory.split path_separator
		master = hierarchy.lastIndexOf 'master'
		ghost = hierarchy.lastIndexOf 'ghost'
		shell = hierarchy.lastIndexOf 'shell'
		if ghost == -1 and shell == -1
			install_txt_path = path.join directory, 'install.txt'
			if fs.existsSync install_txt_path
				return '/'
			else
				return null
		else if master != -1
			if ghost != -1 and (master - ghost) == 1
				
			else if shell != -1 and (master - shell) == 1
			else
				
		fs.exists 'install.txt', (exists) ->
			if exists
				directory = '/'
			else
				fs.exists 'master', (exists) ->
					if exists
						cwd = path.basename(process.cwd())
						if cwd == 'ghost'
							directory = '/ghost'
						else if cwd == 'shell'
							directory = '/shell'
					else
						fs.exists 'ghost', (exists) ->
 */

Germ.Get.Sync = (function(_super) {
  __extends(Sync, _super);

  function Sync() {}

  Sync.prototype.user_agent = 'germ';

  Sync.prototype.package_list_repository_url = function() {
    var package_list_repository_url;
    package_list_repository_url = url.parse('http://germ.narazaka.net/package_list_repository');
    if (this.verbose) {
      console.warn('package_list_repository_url = ' + url.format(package_list_repository_url));
    }
    return package_list_repository_url;
  };

  Sync.prototype.package_txt_url = function(archive_path) {
    var package_txt_url;
    package_txt_url = url.parse(url.resolve(archive_path, './package.txt'));
    if (this.verbose) {
      console.warn('package_txt_url = ' + url.format(package_txt_url));
    }
    return package_txt_url;
  };

  Sync.prototype.package_txt_repository_url = function(package_name) {
    var package_txt_repository_url;
    package_txt_repository_url = url.parse('http://germ.narazaka.net/package_txt_repository/' + package_name + '/package.txt');
    if (this.verbose) {
      console.warn('package_txt_repository_url = ' + url.format(package_txt_repository_url));
    }
    return package_txt_repository_url;
  };

  Sync.prototype.get_package_list = function(callback) {
    return this.get_file(this.package_list_repository_url(), function(error, response, body) {
      if (error) {
        throw error;
      } else if (response.statusCode === 404) {
        throw 'package_list not found';
      } else if (response.statusCode === 200) {
        return callback(body);
      } else {
        throw response.statusCode;
      }
    });
  };

  Sync.prototype.get_package_txt = function(package_name, archive_path, callback) {
    return this.get_file(this.package_txt_url(archive_path), (function(_this) {
      return function(error, response, body) {
        if (error) {
          throw error;
        } else if (response.statusCode === 404) {
          console.warn('package.txt not found in site : using package.txt repository');
          return _this.get_file(_this.package_txt_repository_url(package_name), function(error, response, body) {
            if (error) {
              throw error;
            } else if (response.statusCode === 404) {
              throw 'package.txt not found anywhere';
            } else if (response.statusCode === 200) {
              return callback(body);
            } else {
              throw response.statusCode;
            }
          });
        } else if (response.statusCode = 200) {
          return callback(body);
        } else {
          throw response.statusCode;
        }
      };
    })(this));
  };

  Sync.prototype.get_archive = function(archive_path, callback) {
    var archive_url;
    if (this.verbose) {
      console.warn('Getting archive');
    }
    archive_url = url.parse(archive_path);
    return this.get_binary_file(archive_url, (function(_this) {
      return function(error, response, body) {
        if (error) {
          throw error;
        } else if (response.statusCode === 404) {
          throw 'archive not found in site';
        } else if (response.statusCode = 200) {
          if (_this.verbose) {
            console.warn('Got archive');
          }
          return callback(body, response);
        } else {
          throw response.statusCode;
        }
      };
    })(this));
  };

  Sync.prototype.get_file = function(file_url, callback) {
    return request.get({
      uri: file_url,
      headers: {
        'User-Agent': this.user_agent
      }
    }, callback);
  };

  Sync.prototype.get_binary_file = function(file_url, callback) {
    return request.get({
      uri: file_url,
      encoding: 'binary',
      headers: {
        'User-Agent': this.user_agent
      }
    }, callback);
  };

  return Sync;

})(Germ.Get);

module.exports = Germ;

//# sourceMappingURL=germ.map
